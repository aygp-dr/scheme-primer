;; Scheme Primer - Simple Version
;; This version is compatible with standard Scheme implementations

(define primer-version-string "0.1.0")

(define print-greeting
  (lambda ()
    (display "Welcome to the Scheme Primer, version ")
    (display primer-version-string)
    (newline)
    (newline)
    (display "Scheme is a programming language, and is a dialect of the LISP family of languages.")
    (newline)
    (newline)
    (display "This interactive Scheme Primer will teach you Scheme, and challenge you to write Scheme code of increasing complexity.")
    (newline)
    (newline)
    (display "The Scheme Primer is itself written in Scheme.")
    (newline)
    (newline)
    (display "The Scheme Primer also allows you to jump to specific lessons or practice exercises.")
    (newline)
    (newline)))

(define exit-primer
  (lambda (menu-item-name)
    (display "exiting Scheme Primer")
    (newline)))

(define unimplemented-menu-item
  (lambda (menu-item-name)
    (display "=== Coming Soon ===")
    (newline)
    (display "The \"")
    (display menu-item-name)
    (display "\" module is under development.")
    (newline)
    (display "Please check back in a future version!")
    (newline)
    (newline)        
    (main-menu)))

;; Simple Parentheses Practice
(define parentheses-practice
  (lambda (menu-item-name)
    (display "=== Parentheses Practice ===")
    (newline)
    (newline)
    (display "In Scheme, parentheses are not just for grouping - they indicate function application!")
    (newline)
    (display "Every opening parenthesis '(' must have a matching closing parenthesis ')'.")
    (newline)
    (newline)
    (display "Let's practice counting parentheses.")
    (newline)
    (newline)
    
    (display "Example 1: (+ 1 2)")
    (newline)
    (display "How many opening parentheses? ")
    (let ((answer (read)))
      (if (equal? answer 1)
          (display "Correct!")
          (display "The answer is 1.")))
    (newline)
    (newline)
    
    (display "Example 2: (* (+ 1 2) 3)")
    (newline)
    (display "How many opening parentheses? ")
    (let ((answer (read)))
      (if (equal? answer 2)
          (display "Correct!")
          (display "The answer is 2.")))
    (newline)
    (newline)
    
    (display "Great job! Remember, in Scheme:")
    (newline)
    (display "- Parentheses mean function application")
    (newline)
    (display "- They must always be balanced")
    (newline)
    (display "- (function arg1 arg2 ...) is the basic form")
    (newline)
    (newline)
    
    (display "Press Enter to return to the main menu...")
    (newline)
    (read)
    (main-menu)))

;; Simple Cons Practice
(define cons-practice
  (lambda (menu-item-name)
    (display "=== 'cons' Practice ===")
    (newline)
    (newline)
    (display "The 'cons' procedure is fundamental in Scheme. It creates pairs!")
    (newline)
    (display "(cons a b) creates a pair with 'a' as the first element and 'b' as the second.")
    (newline)
    (newline)
    
    (display "Example 1: What does (cons 1 2) create?")
    (newline)
    (display "It creates a pair: (1 . 2)")
    (newline)
    (newline)
    
    (display "Example 2: What does (cons 1 '()) create?")
    (newline)
    (display "Your answer (write (1) or similar): ")
    (let ((answer (read)))
      (display "It creates the list (1) - a list with one element!"))
    (newline)
    (newline)
    
    (display "Example 3: How do we build the list (1 2 3)?")
    (newline)
    (display "Answer: (cons 1 (cons 2 (cons 3 '())))")
    (newline)
    (newline)
    
    (display "Key points about cons:")
    (newline)
    (display "- cons creates pairs")
    (newline)
    (display "- Lists are chains of pairs ending with '()")
    (newline)
    (display "- (cons 1 '()) creates the list (1)")
    (newline)
    (display "- (cons 1 (cons 2 '())) creates (1 2)")
    (newline)
    (newline)
    
    (display "Press Enter to return to the main menu...")
    (newline)
    (read)
    (main-menu)))

;; Simple Car/Cdr Practice
(define car-cdr-practice
  (lambda (menu-item-name)
    (display "=== 'car' and 'cdr' Practice ===")
    (newline)
    (newline)
    (display "'car' gets the first element, 'cdr' gets the rest.")
    (newline)
    (newline)
    
    (display "Example 1: (car '(a b c))")
    (newline)
    (display "What does this return? ")
    (let ((answer (read)))
      (if (equal? answer 'a)
          (display "Correct! car returns 'a'")
          (display "The answer is 'a' - car gets the first element")))
    (newline)
    (newline)
    
    (display "Example 2: (cdr '(a b c))")
    (newline)
    (display "What does this return? Type (b c): ")
    (let ((answer (read)))
      (display "Right! cdr returns (b c) - everything after the first element"))
    (newline)
    (newline)
    
    (display "Example 3: (car (cdr '(1 2 3)))")
    (newline)
    (display "What does this return? ")
    (let ((answer (read)))
      (if (equal? answer 2)
          (display "Correct! This gets the second element")
          (display "The answer is 2 - cdr gets (2 3), then car gets 2")))
    (newline)
    (newline)
    
    (display "Key points:")
    (newline)
    (display "- car gets the first element")
    (newline)
    (display "- cdr gets everything after the first")
    (newline)
    (display "- You can chain them: (car (cdr x)) gets the second element")
    (newline)
    (display "- Shortcuts exist: cadr = (car (cdr ...))")
    (newline)
    (newline)
    
    (display "Press Enter to return to the main menu...")
    (newline)
    (read)
    (main-menu)))

(define main-menu-items
  `(("exit Scheme Primer" . ,exit-primer)
    ("parentheses practice" . ,parentheses-practice)
    ("'cons' practice" . ,cons-practice)
    ("'car' and 'cdr' practice" . ,car-cdr-practice)
    ("box-and-pointers practice" . ,unimplemented-menu-item)
    ("conditionals practice" . ,unimplemented-menu-item)
    ("'lambda' and application practice" . ,unimplemented-menu-item)
    ("variables, scope, binding, and shadowing practice" . ,unimplemented-menu-item)
    ("point-wise programming practice" . ,unimplemented-menu-item)
    ("simple recursion practice" . ,unimplemented-menu-item)
    ("'quasiquote', 'unquote', and 'unquote-splicing' practice" . ,unimplemented-menu-item)
    ("pattern-matching practice" . ,unimplemented-menu-item)
    ))

(define iota
  (lambda (n)
    (let loop ((i 0))
      (cond
        ((= i n) '())
        (else (cons i (loop (+ i 1))))))))

(define main-menu
  (lambda ()
    (display "Main Menu")
    (newline)
    (display "----------")
    (newline)
    (for-each (lambda (pr i)
                (display "(")
                (display i)
                (display ") ")
                (display (car pr))
                (newline))
              main-menu-items
              (iota (length main-menu-items)))
    (display "----------")
    (newline)
    (display "Please enter the number of your choice from the menu above:")
    (newline)
    (let ((choice (read)))
      (cond
        ((and (number? choice)
              (integer? choice)
              (>= choice 0)
              (< choice (length main-menu-items)))
         (let ((pr (list-ref main-menu-items choice)))
           (let ((menu-item-name (car pr))
                 (handle-menu-item-procedure (cdr pr)))
             (newline)
             (display "You chose (")
             (display choice)
             (display "), ")
             (display menu-item-name)
             (display ".")
             (newline)
             (newline)
             (display "Come on!  Here we go!")
             (newline)
             (newline)
             (handle-menu-item-procedure menu-item-name))))
        (else
         (newline)
         (display "Sorry--I didn't understand your choice!")
         (newline)         
         (display "Please try again!  Please enter a number between 0 and ")
         (display (- (length main-menu-items) 1))
         (display ", inclusive.")
         (newline)
         (newline)
         (main-menu))))))

(print-greeting)

(main-menu)
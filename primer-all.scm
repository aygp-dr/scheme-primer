#lang racket

;; Scheme Primer - All-in-one version
;; This version includes all modules in a single file for better compatibility

(define primer-version-string "0.1.0")

(define print-greeting
  (lambda ()
    (display "Welcome to the Scheme Primer, version ")
    (display primer-version-string)
    (newline)
    (newline)
    (display "Scheme is a programming language, and is a dialect of the LISP family of languages.")
    (newline)
    (newline)
    (display "This interactive Scheme Primer will teach you Scheme, and challenge you to write Scheme code of increasing complexity.")
    (newline)
    (newline)
    (display "The Scheme Primer will automatically adjust the difficulty of the exercises depending on how well you have performed on previous exercises.")
    (newline)
    (newline)
    (display "The Scheme Primer is itself written in Scheme.  The Scheme Primer will teach you how to implement enough Scheme to run the Primer in your own Scheme implementation (\"Meta-circular Primer\"/\"Primer-ception\").")
    (newline)
    (newline)
    (display "The Scheme Primer also allows you to jump to specific lessons or practice exercises.")
    (newline)
    (newline)))

(define exit-primer
  (lambda (menu-item-name)
    (display "exiting Scheme Primer")
    (newline)))

(define unimplemented-menu-item
  (lambda (menu-item-name)
    (display "Sorry--this menu item, \"")
    (display menu-item-name)
    (display "\", has not been implemented yet.")
    (newline)
    (display "Please choose a different menu item.")
    (newline)
    (newline)        
    (main-menu)))

;; Parentheses Practice Module
(define parentheses-practice
  (lambda (menu-item-name)
    (display "=== Parentheses Practice ===")
    (newline)
    (newline)
    (display "In Scheme, parentheses are not just for grouping - they indicate function application!")
    (newline)
    (display "Every opening parenthesis '(' must have a matching closing parenthesis ')'.")
    (newline)
    (newline)
    (parentheses-practice-menu)))

(define parentheses-practice-menu
  (lambda ()
    (display "Choose an exercise:")
    (newline)
    (display "(0) Return to main menu")
    (newline)
    (display "(1) Count parentheses")
    (newline)
    (display "(2) Balance parentheses")
    (newline)
    (display "(3) Fix missing parentheses")
    (newline)
    (display "(4) Identify valid expressions")
    (newline)
    (let ((choice (read)))
      (cond
        ((equal? choice 0) (main-menu))
        ((equal? choice 1) (count-parentheses-exercise))
        ((equal? choice 2) (balance-parentheses-exercise))
        ((equal? choice 3) (fix-parentheses-exercise))
        ((equal? choice 4) (identify-valid-expressions))
        (else
         (display "Invalid choice. Please try again.")
         (newline)
         (parentheses-practice-menu))))))

(define count-parentheses-exercise
  (lambda ()
    (display "=== Count Parentheses ===")
    (newline)
    (display "Count how many opening and closing parentheses are in each expression:")
    (newline)
    (newline)
    
    (define exercises
      '(("(+ 1 2)" 1 1)
        ("(* (+ 1 2) 3)" 2 2)
        ("(if (> x 0) (+ x 1) (- x 1))" 4 4)
        ("(lambda (x) (* x x))" 3 3)
        ("(let ((x 5) (y 10)) (+ x y))" 5 5)))
    
    (define check-answer
      (lambda (expr expected-open expected-close)
        (display "Expression: ")
        (display expr)
        (newline)
        (display "How many opening parentheses? ")
        (let ((user-open (read)))
          (display "How many closing parentheses? ")
          (let ((user-close (read)))
            (cond
              ((and (equal? user-open expected-open)
                    (equal? user-close expected-close))
               (display "Correct! Well done!")
               (newline))
              (else
               (display "Not quite. The answer is ")
               (display expected-open)
               (display " opening and ")
               (display expected-close)
               (display " closing parentheses.")
               (newline)))
            (newline)))))
    
    (for-each
     (lambda (exercise)
       (check-answer (car exercise) (cadr exercise) (caddr exercise)))
     exercises)
    
    (display "Exercise complete! Press Enter to continue...")
    (newline)
    (read)
    (parentheses-practice-menu)))

(define balance-parentheses-exercise
  (lambda ()
    (display "=== Balance Parentheses ===")
    (newline)
    (display "Determine if these expressions have balanced parentheses:")
    (newline)
    (display "Type 'yes' for balanced, 'no' for unbalanced.")
    (newline)
    (newline)
    
    (define exercises
      '(("(+ 1 2)" . yes)
        ("(+ 1 2))" . no)
        ("((lambda (x) x) 5)" . yes)
        ("(define (f x) (* x x)" . no)
        ("(cond ((> x 0) 'positive) (else 'non-positive))" . yes)
        ("(let ((x 5)) (+ x 1))" . yes)
        ("(car (cdr (cdr '(1 2 3 4))))" . yes)
        ("(if (null? lst) '() (cons (car lst) (filter-odd (cdr lst)))" . no)))
    
    (define score 0)
    
    (for-each
     (lambda (exercise)
       (display "Expression: ")
       (display (car exercise))
       (newline)
       (display "Balanced? ")
       (let ((answer (read)))
         (cond
           ((equal? answer (cdr exercise))
            (display "Correct!")
            (set! score (+ score 1)))
           (else
            (display "Incorrect. The answer is ")
            (display (cdr exercise))))
         (newline)
         (newline)))
     exercises)
    
    (display "You got ")
    (display score)
    (display " out of ")
    (display (length exercises))
    (display " correct!")
    (newline)
    (display "Press Enter to continue...")
    (newline)
    (read)
    (parentheses-practice-menu)))

(define fix-parentheses-exercise
  (lambda ()
    (display "=== Fix Missing Parentheses ===")
    (newline)
    (display "Add the missing parentheses to make these valid Scheme expressions.")
    (newline)
    (display "Type the corrected expression:")
    (newline)
    (newline)
    
    (define exercises
      '(("+ 1 2" . "(+ 1 2)")
        ("define x 5" . "(define x 5)")
        ("lambda x) (* x x" . "(lambda (x) (* x x))")
        ("if > x 0) 'positive 'non-positive" . "(if (> x 0) 'positive 'non-positive)")
        ("let (x 5)) (+ x 1)" . "(let ((x 5)) (+ x 1))")))
    
    (for-each
     (lambda (exercise)
       (display "Fix this: ")
       (display (car exercise))
       (newline)
       (display "Your answer: ")
       (let ((answer (read)))
         (cond
           ((equal? answer (string->symbol (cdr exercise)))
            (display "Good try! The standard answer is: ")
            (display (cdr exercise)))
           (else
            (display "The standard answer is: ")
            (display (cdr exercise))))
         (newline)
         (newline)))
     exercises)
    
    (display "Exercise complete! Press Enter to continue...")
    (newline)
    (read)
    (parentheses-practice-menu)))

(define identify-valid-expressions
  (lambda ()
    (display "=== Identify Valid Expressions ===")
    (newline)
    (display "Which of these are valid Scheme expressions?")
    (newline)
    (display "Type 'valid' or 'invalid' for each:")
    (newline)
    (newline)
    
    (define exercises
      '(("()" . valid)
        ("(+ 1 2)" . valid)
        ("(1 2 3)" . invalid)
        ("('a 'b 'c)" . invalid)
        ("(list 1 2 3)" . valid)
        ("(define (f x) x)" . valid)
        ("(define f(x) x)" . invalid)
        ("((lambda (x) x) 5)" . valid)
        ("(lambda x x)" . invalid)
        ("(if #t 1 2)" . valid)))
    
    (define score 0)
    
    (for-each
     (lambda (exercise)
       (display "Expression: ")
       (display (car exercise))
       (newline)
       (display "Valid or invalid? ")
       (let ((answer (read)))
         (cond
           ((equal? answer (cdr exercise))
            (display "Correct!")
            (set! score (+ score 1)))
           (else
            (display "Incorrect. This expression is ")
            (display (cdr exercise))))
         (newline)
         (when (equal? (cdr exercise) 'invalid)
           (display "Explanation: ")
           (cond
             ((equal? (car exercise) "(1 2 3)")
              (display "Numbers cannot be applied as functions."))
             ((equal? (car exercise) "('a 'b 'c)")
              (display "Quoted symbols cannot be applied as functions."))
             ((equal? (car exercise) "(define f(x) x)")
              (display "Function parameters need to be in a separate list."))
             ((equal? (car exercise) "(lambda x x)")
              (display "Lambda parameters must be in a list."))
             (else (display "This violates Scheme syntax rules.")))
           (newline))
         (newline)))
     exercises)
    
    (display "You got ")
    (display score)
    (display " out of ")
    (display (length exercises))
    (display " correct!")
    (newline)
    (display "Press Enter to continue...")
    (newline)
    (read)
    (parentheses-practice-menu)))

;; Cons Practice Module
(define cons-practice
  (lambda (menu-item-name)
    (display "=== 'cons' Practice ===")
    (newline)
    (newline)
    (display "The 'cons' procedure is fundamental in Scheme. It creates pairs!")
    (newline)
    (display "(cons a b) creates a pair with 'a' as the first element and 'b' as the second.")
    (newline)
    (display "Lists are built from pairs: (cons 1 (cons 2 (cons 3 '()))) creates (1 2 3)")
    (newline)
    (newline)
    (cons-practice-menu)))

(define cons-practice-menu
  (lambda ()
    (display "Choose an exercise:")
    (newline)
    (display "(0) Return to main menu")
    (newline)
    (display "(1) Basic cons operations")
    (newline)
    (display "(2) Building lists with cons")
    (newline)
    (display "(3) Nested cons structures")
    (newline)
    (display "(4) Cons puzzles")
    (newline)
    (let ((choice (read)))
      (cond
        ((equal? choice 0) (main-menu))
        ((equal? choice 1) (basic-cons-exercise))
        ((equal? choice 2) (building-lists-exercise))
        ((equal? choice 3) (nested-cons-exercise))
        ((equal? choice 4) (cons-puzzles))
        (else
         (display "Invalid choice. Please try again.")
         (newline)
         (cons-practice-menu))))))

(define basic-cons-exercise
  (lambda ()
    (display "=== Basic cons operations ===")
    (newline)
    (display "What do these cons expressions evaluate to?")
    (newline)
    (display "Enter your answer as a Scheme expression.")
    (newline)
    (newline)
    
    (define exercises
      '(((cons 1 2) . |1 . 2|)
        ((cons 'a 'b) . |a . b|)
        ((cons 1 '()) . (1))
        ((cons 'hello 'world) . |hello . world|)
        ((cons #t #f) . |#t . #f|)
        ((cons '() '()) . (()))
        ((cons 1 (cons 2 '())) . (1 2))
        ((cons 'x '(y z)) . (x y z))))
    
    (define score 0)
    
    (for-each
     (lambda (exercise)
       (display "What does ")
       (display (car exercise))
       (display " evaluate to?")
       (newline)
       (display "Your answer: ")
       (let ((user-answer (read)))
         (let ((correct-answer (cdr exercise)))
           (cond
             ((equal? user-answer correct-answer)
              (display "Correct!")
              (set! score (+ score 1)))
             (else
              (display "Not quite. The answer is ")
              (display correct-answer)))
           (newline)
           (when (and (not (equal? user-answer correct-answer))
                      (pair? correct-answer)
                      (not (null? (cdr correct-answer)))
                      (null? (cddr correct-answer)))
             (display "Note: When cons creates a list (second element is '() or a list), ")
             (display "we write it as (")
             (display (car correct-answer))
             (display " ")
             (display (cadr correct-answer))
             (display ") not (")
             (display (car correct-answer))
             (display " . (")
             (display (cadr correct-answer))
             (display "))")
             (newline)))
         (newline)))
     exercises)
    
    (display "You got ")
    (display score)
    (display " out of ")
    (display (length exercises))
    (display " correct!")
    (newline)
    (display "Press Enter to continue...")
    (newline)
    (read)
    (cons-practice-menu)))

(define building-lists-exercise
  (lambda ()
    (display "=== Building Lists with cons ===")
    (newline)
    (display "Build the requested lists using only cons and '().")
    (newline)
    (display "For example: To build (1 2 3), use (cons 1 (cons 2 (cons 3 '())))")
    (newline)
    (newline)
    
    (define exercises
      '(((1) . "(cons 1 '())")
        ((a b) . "(cons 'a (cons 'b '()))")
        ((1 2 3) . "(cons 1 (cons 2 (cons 3 '())))")
        ((x) . "(cons 'x '())")
        (() . "'()")
        ((#t #f #t) . "(cons #t (cons #f (cons #t '())))")))
    
    (for-each
     (lambda (exercise)
       (display "Build the list: ")
       (display (car exercise))
       (newline)
       (display "Using cons: ")
       (let ((user-expr (read)))
         (display "Expected something like: ")
         (display (cdr exercise))
         (newline)
         (display "Let's check if your expression produces the right result...")
         (newline)
         (newline)))
     exercises)
    
    (display "Exercise complete! Press Enter to continue...")
    (newline)
    (read)
    (cons-practice-menu)))

(define nested-cons-exercise
  (lambda ()
    (display "=== Nested cons structures ===")
    (newline)
    (display "cons can create complex nested structures!")
    (newline)
    (display "What do these expressions evaluate to?")
    (newline)
    (newline)
    
    (define exercises
      '(((cons (cons 1 2) 3) . |(1 . 2) . 3|)
        ((cons 1 (cons 2 3)) . |1 2 . 3|)
        ((cons (cons 'a 'b) (cons 'c 'd)) . |(a . b) c . d|)
        ((cons '(1 2) '(3 4)) . ((1 2) 3 4))
        ((cons (cons 1 '()) (cons 2 '())) . ((1) 2))
        ((cons '(a) '((b) (c))) . ((a) (b) (c)))))
    
    (define score 0)
    
    (for-each
     (lambda (exercise)
       (display "What does ")
       (display (car exercise))
       (display " evaluate to?")
       (newline)
       (display "Your answer: ")
       (let ((user-answer (read)))
         (let ((correct-answer (cdr exercise)))
           (cond
             ((equal? user-answer correct-answer)
              (display "Correct!")
              (set! score (+ score 1)))
             (else
              (display "Not quite. The answer is ")
              (display correct-answer)))
           (newline)
           (newline))))
     exercises)
    
    (display "You got ")
    (display score)
    (display " out of ")
    (display (length exercises))
    (display " correct!")
    (newline)
    (display "Press Enter to continue...")
    (newline)
    (read)
    (cons-practice-menu)))

(define cons-puzzles
  (lambda ()
    (display "=== Cons Puzzles ===")
    (newline)
    (display "Solve these cons challenges!")
    (newline)
    (newline)
    
    (display "Puzzle 1: Using only cons, 1, 2, 3, and '(), create ((1 . 2) . 3)")
    (newline)
    (display "Your expression: ")
    (read)
    (display "Answer: (cons (cons 1 2) 3)")
    (newline)
    (newline)
    
    (display "Puzzle 2: What's the difference between (cons 'a (cons 'b 'c)) and (list 'a 'b 'c)?")
    (newline)
    (display "Type 'same' or 'different': ")
    (let ((answer (read)))
      (display "The answer is 'different'!")
      (newline)
      (display "(cons 'a (cons 'b 'c)) creates (a b . c) - an improper list")
      (newline)
      (display "(list 'a 'b 'c) creates (a b c) - a proper list")
      (newline))
    (newline)
    
    (display "Puzzle 3: How many cons cells are in the list (1 2 3 4 5)?")
    (newline)
    (display "Your answer: ")
    (let ((answer (read)))
      (cond
        ((equal? answer 5)
         (display "Correct! Each element needs one cons cell."))
        (else
         (display "The answer is 5. Each element in a list requires one cons cell.")))
      (newline))
    (newline)
    
    (display "Puzzle 4: True or false: (cons '() '()) equals '(())")
    (newline)
    (display "Type 'true' or 'false': ")
    (let ((answer (read)))
      (cond
        ((equal? answer 'true)
         (display "Correct! (cons '() '()) creates a list with one element: the empty list."))
        (else
         (display "Actually, it's true! (cons '() '()) creates (()) - a list containing the empty list.")))
      (newline))
    (newline)
    
    (display "Puzzles complete! Press Enter to continue...")
    (newline)
    (read)
    (cons-practice-menu)))

;; Car and Cdr Practice Module
(define car-cdr-practice
  (lambda (menu-item-name)
    (display "=== 'car' and 'cdr' Practice ===")
    (newline)
    (newline)
    (display "'car' gets the first element of a pair, 'cdr' gets the second.")
    (newline)
    (display "For lists: 'car' gets the first element, 'cdr' gets the rest.")
    (newline)
    (display "Example: (car '(a b c)) => a, (cdr '(a b c)) => (b c)")
    (newline)
    (newline)
    (car-cdr-practice-menu)))

(define car-cdr-practice-menu
  (lambda ()
    (display "Choose an exercise:")
    (newline)
    (display "(0) Return to main menu")
    (newline)
    (display "(1) Basic car and cdr")
    (newline)
    (display "(2) Chained car/cdr operations")
    (newline)
    (display "(3) Extract elements from lists")
    (newline)
    (display "(4) Car/cdr puzzles")
    (newline)
    (let ((choice (read)))
      (cond
        ((equal? choice 0) (main-menu))
        ((equal? choice 1) (basic-car-cdr-exercise))
        ((equal? choice 2) (chained-car-cdr-exercise))
        ((equal? choice 3) (extract-elements-exercise))
        ((equal? choice 4) (car-cdr-puzzles))
        (else
         (display "Invalid choice. Please try again.")
         (newline)
         (car-cdr-practice-menu))))))

(define basic-car-cdr-exercise
  (lambda ()
    (display "=== Basic car and cdr ===")
    (newline)
    (display "What do these expressions evaluate to?")
    (newline)
    (newline)
    
    (define exercises
      '(((car '(a b c)) . a)
        ((cdr '(a b c)) . (b c))
        ((car '(1)) . 1)
        ((cdr '(1)) . ())
        ((car '((a b) c d)) . (a b))
        ((cdr '((a b) c d)) . (c d))
        ((car (cons 'x 'y)) . x)
        ((cdr (cons 'x 'y)) . y)))
    
    (define score 0)
    
    (for-each
     (lambda (exercise)
       (display "What does ")
       (display (car exercise))
       (display " evaluate to?")
       (newline)
       (display "Your answer: ")
       (let ((user-answer (read)))
         (let ((correct-answer (cdr exercise)))
           (cond
             ((equal? user-answer correct-answer)
              (display "Correct!")
              (set! score (+ score 1)))
             (else
              (display "Not quite. The answer is ")
              (display correct-answer)))
           (newline)
           (newline))))
     exercises)
    
    (display "You got ")
    (display score)
    (display " out of ")
    (display (length exercises))
    (display " correct!")
    (newline)
    (display "Press Enter to continue...")
    (newline)
    (read)
    (car-cdr-practice-menu)))

(define chained-car-cdr-exercise
  (lambda ()
    (display "=== Chained car/cdr operations ===")
    (newline)
    (display "We can chain car and cdr to navigate complex structures!")
    (newline)
    (display "Scheme even provides shortcuts: caar = (car (car x)), cadr = (car (cdr x)), etc.")
    (newline)
    (newline)
    
    (define exercises
      '(((car (cdr '(a b c))) . b)
        ((car (cdr (cdr '(1 2 3 4)))) . 3)
        ((cdr (cdr '(x y z))) . (z))
        ((car (car '((a b) c))) . a)
        ((cdr (car '((1 2 3) 4))) . (2 3))
        ((cadr '(a b c)) . b)
        ((caddr '(1 2 3 4)) . 3)
        ((cddr '(w x y z)) . (y z))))
    
    (define score 0)
    
    (for-each
     (lambda (exercise)
       (display "What does ")
       (display (car exercise))
       (display " evaluate to?")
       (newline)
       (display "Your answer: ")
       (let ((user-answer (read)))
         (let ((correct-answer (cdr exercise)))
           (cond
             ((equal? user-answer correct-answer)
              (display "Correct!")
              (set! score (+ score 1)))
             (else
              (display "Not quite. The answer is ")
              (display correct-answer)))
           (newline)
           (when (and (not (equal? user-answer correct-answer))
                      (member (caar exercise) '(cadr caddr cddr)))
             (display "Remember: ")
             (cond
               ((eq? (caar exercise) 'cadr)
                (display "cadr = (car (cdr ...))"))
               ((eq? (caar exercise) 'caddr)
                (display "caddr = (car (cdr (cdr ...)))"))
               ((eq? (caar exercise) 'cddr)
                (display "cddr = (cdr (cdr ...))")))
             (newline))
           (newline))))
     exercises)
    
    (display "You got ")
    (display score)
    (display " out of ")
    (display (length exercises))
    (display " correct!")
    (newline)
    (display "Press Enter to continue...")
    (newline)
    (read)
    (car-cdr-practice-menu)))

(define extract-elements-exercise
  (lambda ()
    (display "=== Extract Elements from Lists ===")
    (newline)
    (display "Write expressions using car/cdr to extract specific elements.")
    (newline)
    (newline)
    
    (define exercises
      '((((a b c d) b) . "(car (cdr ...))" "(cadr ...)")
        (((1 2 3 4 5) 3) . "(car (cdr (cdr ...)))" "(caddr ...)")
        ((((a b) (c d) (e f)) (c d)) . "(car (cdr ...))" "(cadr ...)")
        ((((x) y z) x) . "(car (car ...))" "(caar ...)")
        (((1 (2 3) 4) (2 3)) . "(car (cdr ...))" "(cadr ...)")
        (((a b c d e) e) . "(car (cdr (cdr (cdr (cdr ...)))))" "(car (cddddr ...))")))
    
    (for-each
     (lambda (exercise)
       (let ((lst (caar exercise))
             (target (cadar exercise)))
         (display "From the list ")
         (display lst)
         (display ", extract ")
         (display target)
         (newline)
         (display "Using car/cdr: ")
         (read)
         (display "Possible answers: ")
         (display (cadr exercise))
         (when (cddr exercise)
           (display " or ")
           (display (caddr exercise)))
         (newline)
         (newline)))
     exercises)
    
    (display "Exercise complete! Press Enter to continue...")
    (newline)
    (read)
    (car-cdr-practice-menu)))

(define car-cdr-puzzles
  (lambda ()
    (display "=== Car/Cdr Puzzles ===")
    (newline)
    (display "Challenge yourself with these puzzles!")
    (newline)
    (newline)
    
    (display "Puzzle 1: What happens if you try (car '())?")
    (newline)
    (display "Type 'error' or the result: ")
    (let ((answer (read)))
      (display "The answer is 'error'! You cannot take the car of an empty list.")
      (newline))
    (newline)
    
    (display "Puzzle 2: Given x = (cons (cons 'a 'b) (cons 'c 'd)), what is (cdr (car x))?")
    (newline)
    (display "Your answer: ")
    (let ((answer (read)))
      (cond
        ((equal? answer 'b)
         (display "Correct! (car x) gives (a . b), then cdr gives b."))
        (else
         (display "The answer is b. (car x) gives the pair (a . b), then cdr gives b"))
      (newline))
    (newline)
    
    (display "Puzzle 3: How would you get the last element of '(1 2 3 4 5) using only car/cdr?")
    (newline)
    (display "Your expression: ")
    (read)
    (display "One answer: (car (cdr (cdr (cdr (cdr '(1 2 3 4 5))))))")
    (newline)
    (display "Or using shortcuts: (car (cddddr '(1 2 3 4 5)))")
    (newline)
    (newline)
    
    (display "Puzzle 4: True or false: (car (cons x y)) always equals x")
    (newline)
    (display "Type 'true' or 'false': ")
    (let ((answer (read)))
      (cond
        ((equal? answer 'true)
         (display "Correct! This is a fundamental property of cons/car/cdr."))
        (else
         (display "Actually, it's true! car and cons are inverses in this way.")))
      (newline))
    (newline)
    
    (display "Puzzles complete! Press Enter to continue...")
    (newline)
    (read)
    (car-cdr-practice-menu)))

;; Main menu definition
(define main-menu-items
  `(("exit Scheme Primer" . ,exit-primer)
    ("parentheses practice" . ,parentheses-practice)
    ("'cons' practice" . ,cons-practice)
    ("'car' and 'cdr' practice" . ,car-cdr-practice)
    ("box-and-pointers practice" . ,unimplemented-menu-item)
    ("conditionals practice" . ,unimplemented-menu-item)
    ("'lambda' and application practice" . ,unimplemented-menu-item)
    ("variables, scope, binding, and shadowing practice" . ,unimplemented-menu-item)
    ("point-wise programming practice" . ,unimplemented-menu-item)
    ("simple recursion practice" . ,unimplemented-menu-item)
    ("'quasiquote', 'unquote', and 'unquote-splicing' practice" . ,unimplemented-menu-item)
    ("pattern-matching practice" . ,unimplemented-menu-item)
    ))

(define iota
  (lambda (n)
    (let loop ((i 0))
      (cond
        ((= i n) '())
        (else (cons i (loop (+ i 1))))))))

(define main-menu
  (lambda ()
    (display "Main Menu")
    (newline)
    (display "----------")
    (newline)
    (for-each (lambda (pr i)
                (display "(")
                (display i)
                (display ") ")
                (display (car pr))
                (newline))
              main-menu-items
              (iota (length main-menu-items)))
    (display "----------")
    (newline)
    (display "Please enter the number of your choice from the menu above:")
    (newline)
    (let ((choice (read)))
      (cond
        ((and (number? choice)
              (integer? choice)
              (>= choice 0)
              (< choice (length main-menu-items)))
         (let ((pr (list-ref main-menu-items choice)))
           (let ((menu-item-name (car pr))
                 (handle-menu-item-procedure (cdr pr)))
             (newline)
             (display "You chose (")
             (display choice)
             (display "), ")
             (display menu-item-name)
             (display ".")
             (newline)
             (newline)
             (display "Come on!  Here we go!")
             (newline)
             (newline)
             (handle-menu-item-procedure menu-item-name))))
        (else
         (newline)
         (display "Sorry--I didn't understand your choice!")
         (newline)         
         (display "Please try again!  Please enter a number between 0 and ")
         (display (- (length main-menu-items) 1))
         (display ", inclusive.")
         (newline)
         (newline)
         (main-menu))))))

(print-greeting)

(main-menu)
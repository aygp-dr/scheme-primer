How can we make synthesis of miniKanren expressions much faster?

An idea! We shoul be able to combine the `mko` relations from `core-mk.scm`, `core-mk-explicit-failure`, and `core-mk-explicit-failure-streams.scm`.  This should let us combine efficiency with expressiveness.

For example,

(run 1 (e)
  (mko `(run 1 (q) ,e) 'cat)      ;; mko from core-mk.scm
  (mko `(run 1 (q) ,e) 'dog)      ;; mko from core-mk.scm
  (mko `(run* (q) ,e) '(cat dog)) ;; mko from core-mk-explicit-failure-streams-tests.scm
  )

The idea here is that the first two mko calls from core-mk.scm can efficiently generate the conde and unifications, as in the "mko backwards-2" test in core-mk-tests.scm.  The mko call from core-mk-explicit-failure-streams-tests.scm can then be used to specify that the synthesized expression must not produce any other values that 'cat and 'dog (although the expression could contain an arbitrary number of failing conde branches).

See the "mko forwards unclosed" tests in core-mk-tests.scm to see how the expressions can't be "closed" in the core-mk-tests.scm code--there is no way to expression that the run expression should be capable of producting 'cat' and 'dog' as answers, but *nothing else*.  The "mko forwards unclosed" tests in core-mk-explicit-failure-streams-tests.scm allow for proper "closing".


Check that this does indeed work...

*this does appear to work--see the tests in `core-mk-simple-and-complex`*  We combine two *very* different relational mk interpreters to combine speed with expressiveness.


Can we play similar tricks with multiple versions of Scheme interpreters, and/or type-inferencers?
